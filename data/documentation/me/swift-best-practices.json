{"identifier":{"url":"doc:\/\/Me\/documentation\/Me\/Swift-Best-Practices","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"patch":0,"major":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/me\/swift-best-practices"]}],"sections":[],"primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","text":"Overview","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Partially these coding guidelines are borrowed from popular ones like:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"https:\/\/github.com\/Lickability\/swift-best-practices","isActive":true}]}]},{"content":[{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/linkedin\/swift-style-guide"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"etc."}]}]}],"type":"unorderedList"},{"level":2,"anchor":"Xcode-Settings","text":"Xcode Settings","type":"heading"},{"level":4,"anchor":"Editor","text":"Editor","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Be sure to have the values below set in ","type":"text"},{"code":"Xcode","type":"codeVoice"},{"text":" > ","type":"text"},{"code":"Settings","type":"codeVoice"},{"text":" > ","type":"text"},{"code":"TextEditing","type":"codeVoice"}]},{"rows":[[[{"inlineContent":[{"type":"text","text":"Display"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Editing"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Indentation"}],"type":"paragraph"}]],[[{"inlineContent":[{"identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/e2505341-ccf5-4010-87cf-7c5bc4144a7b","type":"image"}],"type":"paragraph"}],[{"inlineContent":[{"type":"image","identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/7aaf932d-b77b-4f6b-a097-aade72f1dfea"}],"type":"paragraph"}],[{"inlineContent":[{"type":"image","identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/65f1acc3-dd1c-4c3b-8349-ba2db1748e67"}],"type":"paragraph"}]]],"header":"row","type":"table"},{"level":4,"anchor":"Spell-Checking","text":"Spell Checking","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Enable spell checking under ","type":"text"},{"type":"codeVoice","code":"Edit"},{"text":" > ","type":"text"},{"type":"codeVoice","code":"Format"},{"text":" > ","type":"text"},{"type":"codeVoice","code":"Spelling and Grammar"},{"text":" > ","type":"text"},{"type":"codeVoice","code":"Check Spelling While Typing"},{"text":". We use en-UK","type":"text"},{"text":" ","type":"text"},{"text":"as default language.","type":"text"}]},{"level":2,"anchor":"Misc","text":"Misc","type":"heading"},{"level":4,"anchor":"Avoid-Code-Duplications","text":"Avoid Code Duplications","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way you avoid limitless growing codebase plus, more important, you avoid fixing issues in multiple places. This is one of the most important rules."}]},{"level":4,"anchor":"Dont-use-the-default-case-if-its-possible-that-the-enum-is-extended-in-the-future","text":"Don’t use the default case if it’s possible that the enum is extended in the future","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Switch is an extremely useful construct in Swift since the compiler warns about missing cases. If you use the default case you disable this behavior and loose one of the most powerful features of Swift. It makes sense however to use the default case if you don’t want case-specific behavior for every case, but only for one or some of them. In this case it doesn’t break anything if new cases get added. Also if you switch over plain value types, a default case is harmless.","type":"text"}]},{"level":4,"anchor":"Never-omit-specifying-the-value-of-string-typed-enum-cases","text":"Never omit specifying the value of string-typed enum cases","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Imagine you create a string-typed enum and omit the values for every case since Swift infers the value from the case name. Now when you refactor one enum case from somewhere in your app, the inferred value also changes, which is not desired i.e. in JSON keys. You would introduce hard to find errors.","type":"text"}]},{"level":4,"anchor":"Dont-use-none-in-as-enum-case","text":"Don’t use .none in as enum case","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Your own implementation could easily be confused with "},{"type":"codeVoice","code":"Optional.none"},{"type":"text","text":" when your enum typed property is optional. To avoid this think about an alternative name for this case."}]},{"level":4,"anchor":"Avoid-subclasses-where-possible-and-finalize-your-classes","text":"Avoid subclasses where possible and finalize your classes","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because super- and subclass logic becomes hard to maintain, try to split up logic into separate structs or classes instead. By marking your classes final, some optimizations are enabled which among other things speeds up compilation. Remember that since structs are not inheritable, they are final by design."}]},{"level":4,"anchor":"Set-thickness-of-lines-device-dependent","text":"Set thickness of lines device dependent","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"When you set the thickness of lines to ","type":"text"},{"code":"1.0 \/ UIScreen.main.scale","type":"codeVoice"},{"text":" then the will appear equally on all devices.","type":"text"}]},{"level":4,"anchor":"Localized-strings-used-in-a-framework-F-must-be-defined-there","text":"Localized-strings used in a framework F must be defined there","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If don’t follow this rule, "},{"inlineContent":[{"type":"text","text":"F"}],"type":"strong"},{"type":"text","text":" depends on the target\/module where the string is defined and thus is not modular\/independent anymore. If e.g. another target\/module uses a class of "},{"inlineContent":[{"text":"F","type":"text"}],"type":"strong"},{"type":"text","text":" that contains a localized string which is outside of "},{"inlineContent":[{"type":"text","text":"F"}],"type":"strong"},{"type":"text","text":" the translation could not be found."}]},{"level":4,"anchor":"Name-selectors-with-the-pattern-on<actionname>","text":"Name selectors with the pattern on<action_name>","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Having a unified pattern for naming selectors helps to make code understandable faster. The on* pattern is also used in other programming languages like JavaScript.","type":"text"}]},{"level":4,"anchor":"Avoid-multiple-statements-in-one-line--long-lines","text":"Avoid multiple statements in one line \/ long lines","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"They are harder to read. They are harder to understand. They are even not visible when you work in multiple editor windows side by side - or even worse break to the next line. They could be misunderstood by new developers as an indicator to use it everywhere which will greatly degrade the codebase.","type":"text"}]},{"level":4,"anchor":"Use-typealiases-instead-of-primitive-types-when-appropriate","text":"Use typealiases instead of primitive types when appropriate","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"For example when you have to declare a property in a specific unit like ","type":"text"},{"type":"codeVoice","code":"timeInSeconds"},{"text":" you usually call it ","type":"text"},{"type":"codeVoice","code":"time"},{"text":" and use the type ","type":"text"},{"type":"codeVoice","code":"TimeInterval"},{"text":" which is nothing more than a typalias. Use them to create an implicit context and keep property names swiftily short. Remember: They also appear in code completion and give you a hint about the property that you cannot infer from a short name like in ","type":"text"},{"type":"codeVoice","code":"getWeight() -> Kilograms"},{"text":". The latter example is a much better declaration than ","type":"text"},{"type":"codeVoice","code":"getWeight() -> Double"},{"text":". Read more about that in ","type":"text"},{"identifier":"https:\/\/www.swiftbysundell.com\/posts\/the-power-of-type-aliases-in-swift","type":"reference","isActive":true},{"text":".","type":"text"}]},{"level":4,"anchor":"Use-Camel-Case-for-acronyms-like-URL-or-HTML","text":"Use Camel Case for acronyms like URL or HTML","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"For names like ","type":"text"},{"code":"isHtmlValid","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"isUrlComplete","type":"codeVoice"},{"text":" ","type":"text"},{"identifier":"https:\/\/medium.com\/better-programming\/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841","isActive":true,"type":"reference"},{"text":" improves readability of function and variable names (though it is different than Apple does it). Also see ","type":"text"},{"identifier":"https:\/\/www.hackingwithswift.com\/swift\/3.0\/lower-camel-case","isActive":true,"type":"reference"},{"text":" article.","type":"text"}]},{"level":2,"anchor":"Colors","text":"Colors","type":"heading"},{"level":4,"anchor":"Use-Semantic-Colors","text":"Use Semantic Colors","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Use semantic colors instead of ","type":"text"},{"code":"red","type":"codeVoice"},{"text":", ","type":"text"},{"code":"blue","type":"codeVoice"},{"text":", etc. Semantic colors describe in which context they are used instead of which color they actually are. Good examples are ","type":"text"},{"code":"backgroundColor","type":"codeVoice"},{"text":", ","type":"text"},{"code":"buttonColor","type":"codeVoice"},{"text":", ","type":"text"},{"code":"buttonHighlightColor","type":"codeVoice"},{"text":", ","type":"text"},{"code":"labelColor","type":"codeVoice"},{"text":", etc. Using semantic colors enables the color to automatically adapt to changing OS settings like dark mode or high contrast mode.","type":"text"}]},{"level":2,"anchor":"Framework-Extensions","text":"Framework Extensions","type":"heading"},{"level":4,"anchor":"Never-set-translatesAutoresizingMaskIntoConstraints-manually","text":"Never set translatesAutoresizingMaskIntoConstraints manually","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have the functions "},{"code":"<subview>.addTo(<parent>)","type":"codeVoice"},{"type":"text","text":" and "},{"code":"<subview>.addMaximizedTo(<parent>)","type":"codeVoice"},{"type":"text","text":" which do that automatically."}]},{"level":4,"anchor":"UI-Alerts","text":"UI Alerts","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use UIAlertController extension to display alerts and action sheets."}]},{"level":4,"anchor":"Fonts","text":"Fonts","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Never define a font in code, but rather use or extend the presets in the Fonts enum."}]},{"level":4,"anchor":"Colors","text":"Colors","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Never define a color in code, but rather use or extend the Palette struct and the related UIColor extension."}]},{"level":4,"anchor":"Date-Formatter","text":"Date Formatter","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You don’t have to configure your own ","type":"text"},{"code":"DateFormatter","type":"codeVoice"},{"text":" objects, use ","type":"text"},{"code":"SHDateFormatter","type":"codeVoice"},{"text":" instead. If it doesn’t contain a date format you need, extend it in ","type":"text"},{"code":"SHDateFormatter+Extensions","type":"codeVoice"},{"text":".","type":"text"}]},{"level":4,"anchor":"Hiding-UIStackView-Subviews","text":"Hiding UIStackView Subviews","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the "},{"code":"showArrangedSubview","type":"codeVoice"},{"type":"text","text":" method in the "},{"code":"UIView+Extensions","type":"codeVoice"},{"type":"text","text":" to show or hide arranged subviews."}]},{"level":4,"anchor":"Native-Type-Extensions","text":"Native Type Extensions","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Before implementing extensions on any build-in types, have a look in the ","type":"text"},{"code":"Extensions","type":"codeVoice"},{"text":" framework. We already implemented a lot and most likely it is already there. The rule is when it has no app dependencies it goes to the ","type":"text"},{"code":"Extensions","type":"codeVoice"},{"text":" framework otherwise it should be part of the app.","type":"text"}]},{"level":2,"anchor":"UIView--UIViewController-Architecture","text":"UIView • UIViewController Architecture","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"These guidelines are intended for code-based view\/view controller creation without Interface Builder and teach you how to work Auto Layout programmatically.","type":"text"}]},{"level":4,"anchor":"Use-special-function-to-setup-and-add-EACH-subview","text":"Use special function to setup and add EACH subview","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Setup each subview of a view or view controller in its own function! The Name of the function has to be ","type":"text"},{"code":"private func setup<property_name>","type":"codeVoice"},{"text":". This function should set all parameters necessary for the first setup. This includes ","type":"text"},{"code":"contentHuggingPriority","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"contentCompressionResistancyPriority","type":"codeVoice"},{"text":". It is called only once in init (UIView) or viewDidLoad (UIViewController). Right before the function returns add the view to its superview. This pattern turned out to be one of the cleanest structuring methods possible for the swift language. The advantage is that you have a clean interface of properties on top of the class which helps to recognize all subviews at one glance - in contrast of setting up views in a property closure. Furthermore you can use ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" since these functions are called after initialization. You have a clear overview of the adding order of subviews. Additionally you prevent one long function that sets up all properties of all subviews - typically init or viewDidLoad. Last but not least if you stick to this pattern it is much easier to understand the structure of the whole app since you’ll find this pattern all over again.","type":"text"}]},{"level":4,"anchor":"Use-special-function-to-setup-layout-constraints","text":"Use special function to setup layout constraints","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Always use "},{"type":"codeVoice","code":"private func setupAutoLayout()"},{"type":"text","text":" to create constraints between all subviews! Call it right after the last "},{"type":"codeVoice","code":"private func setup*"},{"type":"text","text":" function in viewDidLoad (UIViewController) or init (UIView). This activates all layout constraints."}]},{"level":4,"anchor":"Configure-view-in-viewDidLoad-or-loadView","text":"Configure view in viewDidLoad (or loadView)","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Never access the view in the initializer of a UIViewController subclass. Accessing the view property causes forces it to be loaded. You should never force the view to be loaded in the initializer since this is done automatically when the view is added to the view hierarchy. By default the view should be created in "},{"type":"codeVoice","code":"loadView()"},{"type":"text","text":". Additional configurations are done in "},{"type":"codeVoice","code":"viewDidLoad()"},{"type":"text","text":". After the view has been loaded you can start making modifications to it like adding subviews, etc."}]},{"type":"paragraph","inlineContent":[{"text":"Sometimes we initialize VCs just to pass it around. Setting up the whole view hierarchy just blocks resources which we do not need at that moment.","type":"text"}]},{"level":2,"anchor":"Access-Qualifier","text":"Access Qualifier","type":"heading"},{"level":4,"anchor":"Declare-symbols-internal-if-you-want-to-test-them","text":"Declare symbols internal if you want to test them","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"To be able to use symbols in tests declare them as ","type":"text"},{"type":"codeVoice","code":"internal"},{"text":" (no prefix) instead of ","type":"text"},{"type":"codeVoice","code":"private"},{"text":" even if they are not used outside of the containing object. If you don’t need to test them and they are not required outside of the containing object declare it as ","type":"text"},{"type":"codeVoice","code":"private"},{"text":".","type":"text"}]},{"level":2,"anchor":"Code-Format","text":"Code Format","type":"heading"},{"level":4,"anchor":"Use-the-self-syntax-exclusively-in-closures-and-appropriate-initializers","text":"Use the self syntax exclusively in closures and appropriate initializers","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"So it will become easier to track down future retain cycles that are caused by missing ","type":"text"},{"code":"[weak self]","type":"codeVoice"},{"text":" in the closure definition. Just leave out ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" if it is not necessary. Also use the ","type":"text"},{"code":"self.","type":"codeVoice"},{"text":" syntax to initially assign constructor parameters to their respective properties if they have the same name.","type":"text"}]},{"level":4,"anchor":"Name-closures-according-to-what-triggers-them","text":"Name closures according to what triggers them","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"I saw that closures have been named according to what they do, e.g.","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"openMenuClosure","type":"codeVoice"}]}]},{"content":[{"inlineContent":[{"code":"displayAccountScreenClosure","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"But closures are no functions. Instead they are more like delegates and we delegate because the delegating object does\/should not know how to or it simply cannot perform a specific task. It only knows ","type":"text"},{"inlineContent":[{"type":"text","text":"how"}],"type":"strong"},{"text":" to trigger it. Therefore better these closures should be named according to their trigger:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"code":"onButtonTap","type":"codeVoice"},{"text":" if we have a generic view which really just has a button","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"onBottomButtonTap","type":"codeVoice"},{"type":"text","text":" if we have multiple buttons and the one in question is named "},{"code":"bottomButton","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"The reason behind all of this is because the action may be part of a reusable piece of code and that code should not know what happens when the action is triggered. This is a general rule of thumb when it comes to modularization\/abstraction\/reuse.","type":"text"}]},{"level":4,"anchor":"Line-Breaks","text":"Line Breaks","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Do not leave a blank line underneath a every function declaration. This results in more compact code blocks which can be perceived as "},{"inlineContent":[{"type":"text","text":"one"}],"type":"strong"},{"type":"text","text":" block easier."}]},{"level":4,"anchor":"Comments","text":"Comments","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Comment functions and properties using ","type":"text"},{"code":"\/\/\/","type":"codeVoice"},{"text":" only if it enhances their comprehensibility. Generally comment code snippets if you think it is reasonable. Sometimes design choices or complex structures are not immediately obvious to understand, in such cases comments are useful for others and your future self.","type":"text"}]},{"level":4,"anchor":"No-file-header","text":"No file header","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Remove comment header for newly created files since it will be always outdated (copyright, spelling errors in file names, etc.)."}]},{"level":4,"anchor":"Symbol-Order","text":"Symbol Order","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Place the nested types at the bottom of the class\/struct definition with a "},{"code":"MARK: - Sub-Types","type":"codeVoice"},{"type":"text","text":" above. Place protocol conformances above these nested types and mark them with their respective protocol name, e.g. "},{"code":"MARK: - StatePresentable","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All other symbols (properties, function, etc.) should be ordered by ascending privateness, so "},{"code":"public","type":"codeVoice"},{"type":"text","text":", "},{"code":"internal","type":"codeVoice"},{"type":"text","text":", "},{"code":"private","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"static"},{"type":"text","text":" symbols are always above "},{"type":"codeVoice","code":"non-static"},{"type":"text","text":" ones."}]},{"level":4,"anchor":"Code-Organization","text":"Code Organization","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Do not use extensions for organizing\/modularizing your code! Instead use "},{"type":"codeVoice","code":"\/\/ MARK: - <#title#>"},{"type":"text","text":" statements to define section in your code."}]},{"type":"paragraph","inlineContent":[{"text":"The advantages of this and specifically moving all protocols in the main object definition are:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the main class declaration shows all conformances of the class\/struct"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"clean method list ("},{"code":"⌃+6","type":"codeVoice"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"a unified file structure results in less searching for symbols, very similar to the "},{"type":"codeVoice","code":"func setup<view>()"},{"type":"text","text":" convention"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"See also the customizable SwiftLint rule "},{"type":"reference","isActive":true,"identifier":"https:\/\/realm.github.io\/SwiftLint\/type_contents_order.html"},{"type":"text","text":"."}]},{"level":4,"anchor":"Name-bools-with-the-pattern-isState","text":"Name bools with the pattern isState","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is easy to read and matches the swifty naming conventions in modern iOS frameworks."}]},{"level":4,"anchor":"Line-Length","text":"Line Length","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Try to achieve a maximum line length of 80-120 characters. This has several reasons:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Some developers work with 2 parallel editors (2 editors, 1 editor \/ 1 canvas, 1 editor \/ 1 assistant \/ etc.) and maybe also the simulator side by side."}]}]},{"content":[{"inlineContent":[{"text":"Horizontal scrolling is quite annoying","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Not every developer has a 4K monitor. Be inclusive!"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"During presentations the font size has to be increased which reduces the available space in the editor","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Many command line applications work with 120 or 80 columns"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In all of the cases above the editor’s code should be fully readable "},{"type":"strong","inlineContent":[{"text":"without","type":"text"}]},{"type":"text","text":" horizontal scrolling and there should be no need to constantly adjust the Xcode panels as this is pretty stressful."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Code that looks ugly with a line-length limit of 80-120 is a great indicator that refactoring is needed."}]},{"type":"paragraph","inlineContent":[{"text":"Please check out the SwiftLint rule ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/realm.github.io\/SwiftLint\/line_length.html"},{"text":".","type":"text"}]},{"level":4,"anchor":"Avoid-typealias-for-Nested-structs","text":"Avoid typealias for Nested structs","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Typealiases have a bunch of advantages but for nested structs, this are the cons:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"When "},{"type":"codeVoice","code":"⌘"},{"type":"text","text":"-clicking the typealias, Xcode will take you to the alias. What you want instead is navigate to the original object."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Quick-Open (","type":"text"},{"code":"⌘ + ⇧ + o","type":"codeVoice"},{"text":") leads you to the typealias. You actually want the original object as suggestion. It also can happen that you end up with multiple suggestions of the same type in the quick-open dialog (one for the alias and one for the real object).","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When you add the same nested object under another parent struct, specifying the same aliases would be confusing. It could even lead to name-space conflicts, depending on where you declare them. In your codebase it hides the information which struct is actually meant."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"When you add a typealias for each nested struct, you would end up with tons of additional code on top of many files."}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"For these reasons I advise against using typealiases for nested objects. If you use them because of line length issues, meanwhile there are nice formatting options in Xcode that streamline indentation (","type":"text"},{"code":"⌃ + m","type":"codeVoice"},{"text":" in combination with SwiftFormat works perfectly).","type":"text"}]},{"level":2,"anchor":"Xcode","text":"Xcode","type":"heading"},{"level":4,"anchor":"No-White-Spaces-In-GroupFolder-Names","text":"No White-Spaces In Group\/Folder Names","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Scripts do not like whitespaces. Since we have a lot of automation by scripts, please use "},{"type":"codeVoice","code":"_"},{"type":"text","text":" as replacement for them."}]},{"level":2,"anchor":"Accessibility","text":"Accessibility","type":"heading"},{"type":"paragraph","inlineContent":[{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/news\/?id=v56qu1b3"},{"type":"text","text":" by Apple is a good introduction and reference for how to use Voice Over."}]},{"level":4,"anchor":"Use-the-accessibilityId-of-a-view-to-make-it-identifiable-in-UnitUI-Tests-or-Voice-Over-announcements","text":"Use the accessibilityId of a view to make it identifiable in Unit\/UI Tests or Voice Over announcements","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The syntax for those identifiers should be "},{"type":"codeVoice","code":"aid.<view_controller>.<ui_element>"},{"type":"text","text":" or if further scoping is needed "},{"type":"codeVoice","code":"aid.<view_controller>.<parent_view>.<ui_element>"},{"type":"text","text":"."}]},{"level":4,"anchor":"Set-the-appropriate-accessibility-traits-if-not-set-automatically","text":"Set the appropriate accessibility traits if not set automatically","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"While buttons usually have it implicitly set, labels functioning as e.g. headers need need their traits set to ","type":"text"},{"code":".header","type":"codeVoice"},{"text":". The same applies for search fields. In cases were a UIView serves as a button, it’s trait should be set to ","type":"text"},{"code":".button","type":"codeVoice"},{"text":".","type":"text"}]},{"level":4,"anchor":"Use-post-notifications-to-inform-about-screenlayout-changes","text":"Use post notifications to inform about screen\/layout changes","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Use it always when a new screen\/popup\/alert is displayed and you want to draw the users attention to it. Use it sparsely in other situations since it interrupts messages spoken by Voice Over on user interaction. An alternative would be to manually refocus an element and re-read it’s label or hint, containing the new information.","type":"text"}]},{"level":4,"anchor":"Disable-Voice-Over-for-images","text":"Disable Voice Over for images","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Blind people cannot see the image. If you enable Voice over here it should be a meaningful and short description of what the image shows.","type":"text"}]},{"level":4,"anchor":"Group-elements-to-declutter-the-UI-for-Voice-Over-users","text":"Group elements to declutter the UI for Voice Over users","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Focusable elements should be kept to the necessary minimum. For example, labels and controls that belong together should be grouped to one accessibility element. The element should have its label’s text for its a11y label and the control as its action. Compare the title + switch cells in the iOS Settings App."}]},{"level":4,"anchor":"Any-colors-should-have-a-sufficient-contrast","text":"Any colors should have a sufficient contrast","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Use at least 4.5:1 for fonts <18pt and 3:1 for fonts >=18pt. You can also read in the official ","type":"text"},{"identifier":"https:\/\/www.w3.org\/TR\/WCAG20\/#visual-audio-contrast-contrast","type":"reference","isActive":true},{"text":" about this topic.","type":"text"}]},{"level":4,"anchor":"Any-view-that-contains-text-should-support-Dynamic-Type","text":"Any view that contains text should support Dynamic Type","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These views should adapt to different font sizes so the UI looks good when the user scales up\/down the font in the iOS settings. Support of the highest Dynamic Type setting is enough. "},{"type":"codeVoice","code":"Larger Accessibility Sizes"},{"type":"text","text":" are not required for now."}]},{"level":2,"anchor":"Testing","text":"Testing","type":"heading"},{"level":4,"anchor":"Extract-testing-code-to-helper-functions","text":"Extract testing code to helper functions","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract testing code to helper functions if you need to write the same testing code over and over again to test similar things. The problem here is that Xcode will report the failure in your helper function. This is easily fixable by writing your function like this: "},{"type":"codeVoice","code":"func verify(file: StaticString = #file, line: UInt = #line) { XCTAssertEqual(1, 3, file: file, line: line) }"},{"type":"text","text":"! The error message will jump to the call site of the extracted function."}]},{"level":4,"anchor":"Prefer-XCTUnwrap-over-guard-let","text":"Prefer XCTUnwrap over guard let","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"XCTUnwrap requires only 1 line instead of at least 3 for the guard. It makes tests much more readable. The error message is even better and most important ","type":"text"},{"inlineContent":[{"type":"text","text":"standardized"}],"type":"strong"},{"text":": ","type":"text"},{"code":"XCTUnwrap failed: expected non-nil value of type \"UIDatePicker\"","type":"codeVoice"},{"text":". No worries the ","type":"text"},{"code":"it","type":"codeVoice"},{"text":" closures of Quick will handle thrown errors correctly.","type":"text"}]},{"level":2,"anchor":"Git","text":"Git","type":"heading"},{"level":4,"anchor":"Conflicts-on-a-branch-have-to-be-resolved-by-the-author","text":"Conflicts on a branch have to be resolved by the author","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is super important since only the author truly knows how to integrate the changes of a branch into the development branch. The author is responsible for the PR and after making the changes ready for review there should not be changes by anybody else because they can lead to issues which fall back to the author in the end. Instead ask the author to do the changes. If conflict resolution is especially difficult, work together with the developer who created the commit that triggers the conflict."}]},{"type":"paragraph","inlineContent":[{"text":"This basically happens during the review.","type":"text"}]}]}],"abstract":[{"type":"text","text":"Here you can find coding guidelines which are battle tested over years."}],"kind":"article","metadata":{"roleHeading":"Article","role":"article","modules":[{"name":"Stefan's Development Hub"}],"title":"Swift Best Practices"},"hierarchy":{"paths":[["doc:\/\/Me\/documentation\/Me","doc:\/\/Me\/documentation\/Me\/Development"]]},"references":{"https://medium.com/better-programming/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841":{"identifier":"https:\/\/medium.com\/better-programming\/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841","url":"https:\/\/medium.com\/better-programming\/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841","title":"Camel Case","titleInlineContent":[{"type":"text","text":"Camel Case"}],"type":"link"},"https://realm.github.io/SwiftLint/line_length.html":{"identifier":"https:\/\/realm.github.io\/SwiftLint\/line_length.html","url":"https:\/\/realm.github.io\/SwiftLint\/line_length.html","title":"line_length","titleInlineContent":[{"text":"line_length","type":"text"}],"type":"link"},"https://realm.github.io/SwiftLint/type_contents_order.html":{"identifier":"https:\/\/realm.github.io\/SwiftLint\/type_contents_order.html","url":"https:\/\/realm.github.io\/SwiftLint\/type_contents_order.html","title":"type_contents_order","titleInlineContent":[{"type":"text","text":"type_contents_order"}],"type":"link"},"doc://Me/documentation/Me/Development":{"title":"Development","role":"collectionGroup","identifier":"doc:\/\/Me\/documentation\/Me\/Development","kind":"article","type":"topic","abstract":[{"type":"text","text":"Swift best practices, review guidelines, interview questions, links and FAQ around (mobile) development."}],"url":"\/documentation\/me\/development","images":[{"type":"card","identifier":"development.png"}]},"doc://Me/documentation/Me":{"kind":"symbol","role":"collection","abstract":[{"text":"I’m Stefan and I’m glad you found the way to my personal development hub and","type":"text"},{"type":"text","text":" "},{"type":"text","text":"portfolio. I love to create open source software, especially development"},{"type":"text","text":" "},{"type":"text","text":"tools, to help other developers to be more productive."}],"identifier":"doc:\/\/Me\/documentation\/Me","type":"topic","images":[{"type":"icon","identifier":"profile.png"}],"url":"\/documentation\/me","title":"Stefan's Development Hub"},"https://github.com/Blackjacx/Development/assets/794372/7aaf932d-b77b-4f6b-a097-aade72f1dfea":{"identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/7aaf932d-b77b-4f6b-a097-aade72f1dfea","alt":"XcodeTextEditingEditing","variants":[{"traits":["1x","light"],"url":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/7aaf932d-b77b-4f6b-a097-aade72f1dfea"}],"type":"image"},"https://github.com/Lickability/swift-best-practices":{"identifier":"https:\/\/github.com\/Lickability\/swift-best-practices","url":"https:\/\/github.com\/Lickability\/swift-best-practices","title":"Lickability","titleInlineContent":[{"type":"text","text":"Lickability"}],"type":"link"},"https://www.hackingwithswift.com/swift/3.0/lower-camel-case":{"identifier":"https:\/\/www.hackingwithswift.com\/swift\/3.0\/lower-camel-case","url":"https:\/\/www.hackingwithswift.com\/swift\/3.0\/lower-camel-case","title":"this","titleInlineContent":[{"text":"this","type":"text"}],"type":"link"},"https://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast":{"identifier":"https:\/\/www.w3.org\/TR\/WCAG20\/#visual-audio-contrast-contrast","url":"https:\/\/www.w3.org\/TR\/WCAG20\/#visual-audio-contrast-contrast","title":"WCAG20 docs","titleInlineContent":[{"type":"text","text":"WCAG20 docs"}],"type":"link"},"https://www.swiftbysundell.com/posts/the-power-of-type-aliases-in-swift":{"identifier":"https:\/\/www.swiftbysundell.com\/posts\/the-power-of-type-aliases-in-swift","url":"https:\/\/www.swiftbysundell.com\/posts\/the-power-of-type-aliases-in-swift","title":"Sundells Blog Article","titleInlineContent":[{"text":"Sundells Blog Article","type":"text"}],"type":"link"},"development.png":{"identifier":"development.png","alt":"A technology icon representing mobile development.","variants":[{"traits":["2x","light"],"url":"\/images\/development@2x.png"}],"type":"image"},"profile.png":{"identifier":"profile.png","alt":"A picture of the author","variants":[{"traits":["2x","light"],"url":"\/images\/profile@2x@2x.png"}],"type":"image"},"https://github.com/Blackjacx/Development/assets/794372/e2505341-ccf5-4010-87cf-7c5bc4144a7b":{"identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/e2505341-ccf5-4010-87cf-7c5bc4144a7b","alt":"XcodeTextEditingDisplay","variants":[{"traits":["1x","light"],"url":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/e2505341-ccf5-4010-87cf-7c5bc4144a7b"}],"type":"image"},"https://github.com/linkedin/swift-style-guide":{"identifier":"https:\/\/github.com\/linkedin\/swift-style-guide","url":"https:\/\/github.com\/linkedin\/swift-style-guide","title":"LinkedIn","titleInlineContent":[{"text":"LinkedIn","type":"text"}],"type":"link"},"https://developer.apple.com/news/?id=v56qu1b3":{"identifier":"https:\/\/developer.apple.com\/news\/?id=v56qu1b3","url":"https:\/\/developer.apple.com\/news\/?id=v56qu1b3","title":"This article","titleInlineContent":[{"type":"text","text":"This article"}],"type":"link"},"https://github.com/Blackjacx/Development/assets/794372/65f1acc3-dd1c-4c3b-8349-ba2db1748e67":{"identifier":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/65f1acc3-dd1c-4c3b-8349-ba2db1748e67","alt":"XcodeTextEditingIndentation","variants":[{"traits":["1x","light"],"url":"https:\/\/github.com\/Blackjacx\/Development\/assets\/794372\/65f1acc3-dd1c-4c3b-8349-ba2db1748e67"}],"type":"image"}}}